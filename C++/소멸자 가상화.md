
```cpp
#include "stdafx.h"

class A {
private: 
	int num = 1;
public :
	A() {
		cout << "A의 생성자" << endl;
	}
	 ~A() {
		cout << "A의 소멸자" << endl;
	}
};

class B :public A{

private:
	int num = 1;
public:
	B() {
		cout << "B의 생성자" << endl;
	}
	~B() {
		cout << "B의 소멸자" << endl;
	}
};

int main() {
	A* pdata = new B;
	cout << "ddd";
	
	delete pdata;
	return 0;
}
```
B의 클래스는 A의 클래스를 상속 받는다. 
이후 클래스를 사용한 뒤 delete 연산자를 통해서 해당 객체를 삭제한다고 가정하였을 때 어떤 클래스의 소멸자가 호출이 되겠는가?

정답은  A의 클래스가 호출된다. 즉, 참조 형식인 A 클래스의 소멸자가 호출된다. 소멸자는 클래스의 호출과 실행이 동시에 된다. 참조 형식인 A클래스의 소멸자가 호출되면서 클래스의 메모리를 해제한다. 그러나 실 형식인 B클래스의 소멸자가 호출되지 않아 메모리 누수와 같은 문제를 발생하게 된다. 

객체지향은 시간적 개념이 추가된 것 이라고 하였다. 
A클래스를 20년도에 만들고 기능 확장을 위해 B클래스를 현재 추가적으로 작성하였다고 가정하자. 
A 클래스를 상속을 받은 B클래스의 기능을 확장하고 이후 모든 기능을 사용한 뒤 메모리에서 해제한다고 하자.  앞서 말했듯이 delete 연산자를 사용하여 A클래스 참조형식의 B클래스를 메모리 해제 하고 싶어도 A의 소멸자만 호출과 실행이 되기 때문에 메모리에는 실형식 클래스의 유령이 남는다. 

메모리를 살펴보면 다음과 같다. A 클래스 참조형식의 실형식 B 클래스를 인스턴스화 하면 다음과 같이 메모리 주소가 작성된다.

![[Pasted image 20231105220737.png]]
이후 모든 기능이 종료되고 현재 개발자가 delete연산자를 사용하여 해당 객체를 메모리에서 해제하고 싶어도 다음과 같이 실형식 클래스의 주소가 남아있는 것을 볼 수 있다. 
![[Pasted image 20231105220756.png]]

이 문제는 과거의 개발자가 설계 시 고려를 해야하는 부분이다. 해당 클래스가 기능적으로 상속시킬 클래스라면 해당 클래스를 상속받은 새로운 클래스의 메모리 해제도 고려한다는 것으로 실로 머리아픈 일이 아닐 수 없다. 다행이게도? virtual 예약어만 소멸자 앞에 붙인다면 해당 문제를 예방할 수 있다.
A의 참조형식을 가진 실형식 B 클래스의 주소가 다음과 같을 때 
![[Pasted image 20231105220830.png]]
소멸자 가상화를 시킨다면 다음과 같이 메모리가 모두 해제 되는 것을 볼 수 있다.
![[Pasted image 20231105220851.png]]



```cpp
#include "stdafx.h"

class A {
private: 
	int num = 1;
public :
	A() {
		cout << "A의 생성자" << endl;
	}
	// 소멸자를 가상화하여 상속 받을 클래스의 메모리를 관리해주자
	 virtual ~A() {
		cout << "A의 소멸자" << endl;
	}
};

class B :public A{

private:
	int num = 1;
public:
	B() {
		cout << "B의 생성자" << endl;
	}
	~B() {
		cout << "B의 소멸자" << endl;
	}
};

int main() {
	A* pdata = new B;
	cout << "ddd";
	
	delete pdata;
	return 0;
}
```

